# 《程序员练级攻略》分析笔记

本文整理了《开篇词》和《程序员练级攻略的正确打开方式》两篇文章的内容。

## Q1: 这个教程属于哪一类别的教程

计算机/方法论。

## Q2：这个教程的内容是什么

介绍程序员自我提高的方法及资源。

## Q3：这个教程的大纲是什么

- 开篇词
- 入门篇
  - [1 零基础启蒙][1]
  - [2 正式入门][2]
- 修养篇
  - [3 程序员修养][3]
- 专业基础篇
  - [4 编程语言][4]
  - [5 理论学科][5]
  - [6 系统知识][6]
- 软件设计篇
  - [7 软件设计][7]
- 高手成长篇
  - [8 Linux 系统、内存和网络（系统底层知识）][8]
  - [9 异步 I/O 模型和 Lock-Free 编程（系统底层知识）][9]
  - [10 Java 底层知识][10]
  - [11 数据库][11]
  - [12 分布式架构入门（分布式架构）][12]
  - [13 分布式架构经典图书和论文（分布式架构）][13]
  - [14 分布式架构工程设计（分布式架构）][14]
  - [15 微服务][15]
  - [16 容器化和自动化运维][16]
  - [17 机器学习和人工智能][17]
  - [18 前端基础和底层原理（前端方向）][18]
  - [19 前端性能优化和框架（前端方向）][19]
  - [20 UI/UX 设计（前端方向）][20]
  - [21 技术资源集散地][21]
  - [22 程序员练级攻略的正确打开方式][22]

## Q4：作者想要解决什么问题

## Q5：这个教程的关键词是什么

## Q6：这个教程的关键句是什么

### 前言导读

- 入门篇
  - Python
  - JavaScript
  - Linux
  - Visual Studio Code
  - Web 编程入门
  - Java

- 程序员修养
  - 程序员修养反映出程序员的工程师特质和价值观，决定了这条路你到底能走多远，是精髓所在。
  - **有修养的程序员才可能成长为真正的工程师和架构师，而没有修养的程序员只能沦为码农，这是码农和工程师的关键区分点。**
  - 程序员修养包含：英文能力、提问的能力、写代码的修养、安全防范意识、软件工程和上线规范、编程规范等。

- 专业基础
  - 编程语言：推荐学习 C、C++ 和 Java 这三个工业级的编程语言。
  - 理论学科：需要学习算法、数据结构、网络模型、计算机原理等内容。
  - 系统知识：需要学习 Unix/Linux、TCP/IP、C10K 挑战等专业的系统知识。

- 软件设计
  - 编程范式：泛型编程、函数式编程、面向对象编程等
  - 软件设计原则：DRY- 避免重复原则、KISS- 简单原则、迪米特法则（又称“最少知识原则”）、 面向对象的 S.O.L.I.D 原则等

- 高手成长
  - 涵盖系统、数据库、分布式架构、微服务、容器化和自动化运维、机器学习、前端方向和技术论文等几方面内容
  - 深度一下子拔高了好几个数量级

- 从业方向
  - 如果你对操作系统、文件系统、数据库、网络等比较感兴趣，那么可以考虑从事底层方面的工作。
  - 如果对分布式系统架构、微服务、DevOps、Cloud Native 等有热情，那么可以从事架构方面的工作。
  - 如果是对大数据、机器学习、人工智能等比较关注，那么数据领域可以成为你一展身手的地方。
  - 如果你对用户体验或者交互等更感兴趣，那么前端工程师也是个不错的选择。
  - 此外，安全开发、运维开发、嵌入式开发等几大方向中，也为你提供了丰富多彩的发展空间。

- 关于就业选择的两个观点
  - 各种技术方向不是鱼和熊掌，是可以兼得的。
  - 很多技术是相通的，关键是你是学在表面还是深入本质。

### 注意事项

- 《入门篇》和《专业基础篇》中的那些书和文章，你肯定是得认真精读的，这是基础。（精读）
  - 但是也没有必要揪住细节不放，重要的是知道这个技术的“解题思路”，抓住其中的重点，一个技术的关键点就那么几个。

- 《高手成长篇》的相关书籍、文章和论文，你不一定全读，可以挑感兴趣的内容研究。（选读）

- 《修养篇》和《设计篇》里的内容，你可能要经常拿出来读。（常读）
  - 因为这些都是经验，随着你的成长，以及阅历的增加，你每次读都会收获更多新东西，正所谓常看常新。
  - 另外，你还可以顺着这些东西找到更多的“修养”和“设计”。

### 回答问题

#### 问题1：理论和现实的差距大怎么办

- 并不是理论和现实的差距大，而是你还没有找到相关的场景，来感受到那些学院派知识的强大威力。
- 算法与数据结构、操作系统原理、编译原理、数据库原理、计算机原理……这些原理上的东西，是你想要成为一个专家必须要学的东西。
- 这就是“工人”和“工程师”的差别，是“建筑工人”和“建筑架构师”的差别。
- 如果你觉得这些理论上的东西无用，那么只能说明，你只不过在从事工人的工作，而不是工程师的工作。

#### 问题2：技术能力遇到瓶颈无法提升怎么办

- 技术能力的瓶颈，以及技术太多学不过来，只不过是你为自己的能力不足或是懒惰找的借口罢了。
- 技术的东西都是死的，这些死的知识只要努力就是可以学会的。只不过聪明的人花得时间少，笨点的人花得时间多点罢了。
- 这其中的时间差距主要是由学习方法的不同，基础知识储备的不同决定的。只要你方法得当，多花点时间在基础知识上，会让你未来学习应用知识的时间大大缩短。
- 以绝大多数人努力的程度，和为自己不努力找借口的程度为参考，只要你坚持正常的学习就可以超过大多数人了。

#### 问题3：技术太多学不过来怎么办

- 这里没有学习技术的速成的方法，真正的牛人不是能够培训出来的，一切都是要靠你自己去努力和持续地付出。
- 这篇文章中的成长路径是需要思考、精力和相关的经验的，这都需要时间，而且是不短的时间。
- 你先问问自己有没有花十年磨一剑的决心，如果没有，那这篇文章对你没有任何作用。

### 学习建议

以下是《开篇词》提出的建议：

- 一定要坚持，要保持长时间学习，甚至终生学习的态度。
- 一定要动手，不管例子多么简单，建议至少自己动手敲一遍看看是否理解了里头的细枝末节。
- 一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。
- 不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累，会在未来至少 10 年通用。
- 回顾一下历史，看看历史时间线上技术的发展，你才能明白明天会是什么样的。

以下是《程序员练级攻略的正确打开方式》提出的建议：

- 带着一些具体的问题来学习，能够让你更有感觉，也容易获得正反馈和成就感。
- 开拓视野，尽可能只读英文社区的一手文章，这样你会得到更有营养的知识。
- 多问为什么，为什么要设计成这样，为什么要有这个技术，到底解决了什么样的问题？这会让你对技术有更深的认识。
- 学会归纳总结，在不同的技术中找到相似或是相同的东西，更容易让你触及技术的本质。
- 把自己的理解用自己的语言表达出来，对外输出，这是最好的学习方式。
- “动手”和“坚持”，这是一个动手能力很强的学科，不动手，你什么都不可能学精、学深。
  这是一个需要你不断坚持的事，在这条路上，你有很多很多的理由可以让你放弃，只有坚持才有可能有突破。

> 伍注：两篇文档的建议中，重复提到了三个关键词：坚持、动手、学会思考。

### 动手实践的三个级别

#### 第一级：建立自己的实验室

- 实验室的要求
  - 看完理论知识，徒手把环境搭出来，写一些实验性的程序验证或感受一下相关的技术点，出了问题也要自己进行调试和修复。
  - 只有这样，你才可以获得一些感性认识。

- 实验室的项目
  - 学习编程语言。推荐 Java 和 JavaScript。
  - 做《入门篇》和《专业基础篇》里面的实践项目。
  - 做《数据结构》和《算法》的练习。把它们作为脑力体操来不断训练自己的数学思维。
  - 搭环境验证《高手成长篇》中的很多东西。
    - 自己先搭个环境，写一些 Hello World 式的程序先体会一下那些知识。
      比如内存分配、异步 I/O 模型、locker-free、JVM 和字节码操作，还有浏览器原理等等这些东西，写几个小程序就可以体会到了。
    - 而还有一些中间件的知识，你也是可以搭个环境自己玩玩，并且最好能够搭出一些比较高级的用法。

#### 第二级：把你的实验室升级成工作室

- 工作室的要求
  - 工作室和实验室不一样的地方是，实验室只是在做一些验证型的实验，以跑通一个小技术功能为主。
    而工作室则是要以完成一个比较完整的软件功能为主，也就是说，可以让别人 / 用户来用的东西（哪怕很丑很难用，但是可以让别人来用）。

- 工作室的项目
  - 第一，从自己的痛点出发，写一个能解决自己问题的东西。
  - 第二，临摹别人的作品，复刻一个其它的成功产品。
    有人说，学好一门语言或是一个开源软件最好的方式，就是用想学/喜欢的编程语言翻译下这个开源软件，比如用 Go 语言翻译一下某个 Java 的组件。
  - 第三，深度参与一些你喜欢的开源项目。
  - 第四，在工作中找到风险可控的项目和需求。

- 工作室的建议
  - 选用主流的开发框架
  - 写软件时要有一定的编程修养，比如有不错的编程风格，追求代码的可读性，有一定的测试用例
  - 大量学习一些优秀项目的代码，因为你可以在开源软件中找到一些不错的代码实现
    （你可以做一些源码分析的事，但不是去整理其中的编程逻辑，而是要去学习代码组织的方法）
  - 你最好跟别人一起组队升级打怪。
  - 当你的东西做好后，一定要做压力测试或 Benchmark，这样你才知道自己产品与其他软件的差距，然后还会逼着你对自己的系统或软件进行调优。

#### 第三级：把你的工作室升级成工厂

- 工厂的要求
  - 工作室与工厂最大的差别就是，工作室是比较自我比较随意的，而工厂是有相关的工业标准的，是有一整套的规范和标准的。

- 工厂的建议
  - 你就可以去头部的互联网公司或是一些技术公司了。但是你一定要在一些核心的项目或产品工作，
    也就是说，你要在那些有技术挑战的地方工作，并在那里收割更多的经验和技能。
  - 你需要读各种各样的 RFC、论文、Specificaiton、标准化文档，还要使用工业级的工程能力要求自己，比如，CI/CD 这样的软件流程。
    你得不断告诉自己，把代码提高到可维护、可扩展，甚至可重用的级别。
  - 你必须对技术有更深入的了解，对软件开发的套路和各种 trade-off 还有各种解决方案的优缺点都非常熟悉。
    这就需要你了解软件内部的设计和原理，并知道优缺点和使用场景。
  - 你需要开始追求软件运行的 SLA，也就是能在什么样的性能下做到多少个 9。还要关注系统的可运维性，也就是你需要为你的软件做很多的配套设施。
  - 这个时候，对于你要做的软件，你不仅仅只是为了完成，你追求的是一种技术高度，追求那种严谨和科学的态度。
    你已经把这个软件当成了自己作品，变成了自己的名片，你在等待接受别人的学习和膜拜。

## Q7：作者是怎么论述的

## Q8：作者解决了什么问题

## Q9：我有哪些疑问

## Q10：这个教程说得有道理吗？为什么

## Q11: 这个教程讨论的知识的本质是什么

## Q12: 这个教程讨论的知识的第一原则是什么

## Q13：这个教程讨论的知识的结构是怎样的

## Q14：这个教程讨论的知识为什么是这样的？为什么发展成这样？为什么需要它

## Q15：有哪些相似的知识？它们之间的联系是什么

## Q16：其他领域/学科有没有相关的知识？日常生活中有没有类似的现象

## Q17: 这个教程对我有哪些用处/帮助/启示

### 一些值得我优先学习的资料

- [The Key To Accelerating Your Coding Skills][r1]
- [Two Minute Papers][r2]
- [慕课网在线课程：数据库设计的那些事][r3]
- [超完整的 Chrome 浏览器客户端调试大全][r4]
- [What are some of the most basic things every programmer should know?][r5]
- [Things Every Programmer Should Know][r6]
- [How To Ask Questions The Smart Way][r7]
- [X-Y Problem][r8]
  - 中文版：[X-Y 问题][r9]
- [FAQ for StackExchange Site][r10]
- [陈皓「极客时间」课程：《编程范式游记》][r11]
- [The Twelve-Factor App][r12]
- [The Twelve-Factor App（中文版）][r13]
- [Building Software Systems At Google and Lessons Learned][r14]
  - 2010 年，斯坦福大学请杰夫·迪恩到大学里给他们讲了一节课，回顾了 Google 发展的历史。
- [How to read an academic article][r15]
- [How to read and understand a scientific paper][r16]
- [Should I Read Papers?][r17]
- [The Refreshingly Rewarding Realm of Research Papers][r18]

## Q18: 我如何应用这个教程的知识去解决问题

  [r1]: http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/
  [r2]: https://www.youtube.com/user/keeroyz
  [r3]: https://www.imooc.com/learn/117
  [r4]: https://www.shouce.ren/api/view/a/12775
  [r5]: https://www.quora.com/What-are-some-of-the-most-basic-things-every-programmer-should-know
  [r6]: https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/index.html
  [r7]: http://www.catb.org/~esr/faqs/smart-questions.html
  [r8]: https://xyproblem.info/
  [r9]: https://coolshell.cn/articles/10804.html
  [r10]: https://meta.stackexchange.com/questions/7931/faq-for-stack-exchange-sites
  [r11]: https://time.geekbang.org/column/article/301
  [r12]: https://12factor.net/
  [r13]: https://12factor.net/zh_cn/
  [r14]: https://www.youtube.com/watch?v=modXC5IWTJI
  [r15]: https://organizationsandmarkets.com/2010/08/31/how-to-read-an-academic-article/
  [r16]: https://violentmetaphors.com/2013/08/25/how-to-read-and-understand-a-scientific-paper-2/
  [r17]: http://michaelrbernste.in/2014/10/21/should-i-read-papers.html
  [r18]: https://www.youtube.com/watch?v=8eRx5Wo3xYA

  [1]: ./01_get_started_for_zero-based.md
  [2]: ./02_get_started_formally.md
  [3]: ./03_programmer_culture.md
  [4]: ./04_programming_language.md
  [5]: ./05_subjects.md
  [6]: ./06_system_knowledge.md
  [7]: ./07_software_design.md
  [8]: ./08_linux_memory_network.md
  [9]: ./09_asynchronous_io_and_lock_free_programming.md
  [10]: ./10_java.md
  [11]: ./11_database.md
  [12]: ./12_get_started_with_distributed_architecture.md
  [13]: ./13_distributed_architecture_books_and_papers.md
  [14]: ./14_distributed_architecture_design.md
  [15]: ./15_microservices.md
  [16]: ./16_container_and_ops_automation.md
  [17]: ./17_machine_learning_and_ai.md
  [18]: ./18_frontend_basic_and_principle.md
  [19]: ./19_frontend_performance_improvement.md
  [20]: ./20_ui_ux_design.md
  [21]: ./21_tech_resource.md
