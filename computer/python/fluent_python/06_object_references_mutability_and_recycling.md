# Fluent Python 分析笔记

## 6 Object References, Mutability, and Recycling

### 这一章的大纲是什么

- 变量不是盒子
- 对象的 id、取值和别名
- 浅复制（默认）和深复制
- 引用与函数参数
- 垃圾回收与 del 命令
- Python 处理不可修改对象的技巧

### 目前为止我知道什么

- Python 不是为每个变量都单独分配内存空间的，比如取值相同的整数变量就共享同一个内存空间。
  这应该便是「变量不是盒子」想表达的意思。
- 我猜测：自定义对象默认分配不同内存空间，内建对象默认分配相同的内存空间？
- 对象的 id 是存储该对象的内存地址（类比「门牌号」），对象的取值是该对象对应的内容（类比「房子里存放的东西」）。
- 浅复制和深复制的区别：简单复制引用，不需重新分配内存空间，是浅复制；重新分配内存空间，再复制数据到新的内存空间， 是深复制。
- 引用与函数参数：如果函数参数以引用的形式传递时，函数内部对该参数的修改，在函数退出时依然生效；
  如果函数参数以数值的形式传递时，函数内部对该参数的修改，在函数退出后不再生效。

### 目前为止我不知道什么

- 什么时候变量共享同一个内存空间
- 什么时候出现这种情况：两个变量共享同一个内存空间，修改其中一个变量后，两个变量不再共享同一个内存空间
- 对象的别名是什么东西
- 什么时候进行浅复制、什么时候进行深复制
- Python 函数参数什么时候是以引用的形式传递，什么时候是以数值的形式传递
- Python 的垃圾回收机制是怎样的
- Python  del 命令的用法与原理是什么
- Python 处理不可修改对象的技巧

### 这一章的主要内容是什么

- 变量是标签（引用），而非盒子
  - 赋值语句实际上是将一个名字绑定到一个对象上
  - 因此赋值前对象必须先存在，这样才能将一个名字绑定到它上面
  - 产生的后果
    - 简单的赋值不会导致复制
    - 对于 `+=` 或 `*=`，如果左边操作数不可变，那么会创建新对象；
      如果左边操作数可变，那么可能会原地修改它。
    - 赋值给一个已存在的变量不会修改它之前绑定的对象，而是重新绑定到新对象。
      如果旧对象的引用计数变为0，就会被垃圾回收。
    - 函数是引用传参，因此函数可能修改任何传入的可变变量，并且没有方法阻止这个行为。
      除非使用本地赋值或不可变变量。
    - 使用可变对象作为默认参数是个危险行为。

- id 与别名
  - id 可以理解为内存地址（在 CPython 中，id() 返回的就是对象的地址）
  - 指向同一个对象（即id相同）的多个变量称为「别名」（alias）
  - 创建内建对象时，相同取值的对象的 id **可能** 是相同的。
  - 创建非内建对象时，相同取值的对象的 id 是不同的。
  - 将一个变量赋值给另一个变量后，这两个变量的 id 是相同的。

  ```python
  >>> a = 1
  >>> b = 1
  >>> id(a), id(b)
  (140530952782064, 140530952782064)
  >>> e = 257
  >>> f = 257
  >>> id(e), id(f)
  (140415998594832, 140415998595920)
  >>> c = [1]
  >>> d = [1]
  >>> id(c), id(d)
  (140530950776192, 140530950825024)
  ```

- 相等性：`==` vs `is`
  - `==` 比较两个对象的取值（即它们存有的数据）
  - `is` 比较两个对象的 id （即它们的内存地址）

  ```python
  >>> foo = (1,)
  >>> bar = (1,)
  >>> id(foo), id(bar)
  (139919516367456, 139919514844848)
  >>> foo == bar
  True
  >>> foo is bar
  False
  >>> cat = None
  >>> id(cat), id(None)
  (9863040, 9863040)
  >>> cat == None
  True
  >>> cat is None
  True
  ```

- 元祖的相对不可变性
  - 元祖保存的元素的引用（内存地址）是不可变的
  - 元祖保存的元素的数据可能是可变的，取决于元素的类型

  ```python
  >>> foo = (1, 2, [3,4])
  >>> foo[0] = 10
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
  TypeError: 'tuple' object does not support item assignment
  >>> foo[2].append(5)
  >>> foo
  (1, 2, [3, 4, 5])
  ```

- 浅复制和深复制
  - 默认浅复制
  - copy.copy 是浅复制，copy.deepcopy 是深复制

  ```python
  >>> l1 = [3, [55, 44], (7, 8, 9)]
  >>> l2 = list(l1)
  >>> id(l1[1]), id(l2[1])
  (139919513560128, 139919513560128)
  >>> l1[1].append(66)
  >>> l1
  [3, [55, 44, 66], (7, 8, 9)]
  >>> l2
  [3, [55, 44, 66], (7, 8, 9)]
  ```

- Python 函数参数以引用的方式传递
  - 最佳实践1：默认参数应该为不可变类型
  - 最佳实践2：定义一个接收可变参数的函数时，如果函数内部不应修改它，采取深复制的方法。

- `del`
  - `del` 不是函数，而是语句
  - `del` 删除引用，而非对象

- Python 垃圾回收
  - CPython 垃圾回收的机制是引用计数，计数为0时立即销毁对象
  - CPython 2.0 增加了克服引用循环的问题的算法
  - 其他实现不一定使用引用计数机制，因此不一定及时回收内存

- Python 对不可变对象的处理（interning）
  - tuple
  - str
  - bytes
  - frozenset
  - number

  ```python
  >>> t1 = (1, 2, 3)
  >>> t2 = tuple(t1)
  >>> t2 is t1
  True
  >>> t3 = t1[:]
  >>> t3 is t1
  True
  ```

  ```python
  >>> t1 = (1, 2, 3)
  >>> t2 = (1, 2, 3)
  >>> t3 is t1
  False
  >>> s1 = 'abc'
  >>> s2 = 'abc'
  >>> s1 is s2
  True
  ```

### 这一章的知识本质、第一原则和结构是什么

第6章的知识本质是引用，类似C语言的指针，说白了就是内存地址。

第6章的知识第一原则是：Python 变量都是引用，编程中要注意避免误修改数据。

第6章的知识结构是：什么是引用、哪些地方需要注意引用（赋值、复制、删除、函数传参、不可变对象）
